---
title: 数据结构
date: 2021-12-13 11:34:49
draft: true
categories:
 - 书籍笔记
tags:
 - 数据结构
 - C/C++
---
# 数据结构笔记(C语言)

## 写在前面

形参是实参的拷贝，指针是内存中的地址，引用变量是已经存在的变量的另一个名字（引用属于C++）。

1. 普通变量做形参

   因为形参是实参的拷贝，传入实参并不能修改实参的值

   ```cpp
   void fun(int a){
       a=8;
   }
   int main(){
       int a=2;
       fun(a);
       printf("a的值为：%d",a);
       return 0;
   }
   ```

   ```bash
   a的值为：2
   ```

2. 指针做形参

   指针是内存中的地址，指针做形参能够更改实参的值（但指针形参依然是main函数内指针的拷贝，只是地址相同）

   ```cpp
   void fun(int * p){
       *p=8;
   }
   int main(){
       int *p;
       int a=2;
       p=&a;
       fun(p);
       printf("a的值为：%d",a);
       return 0;
   }
   ```

   ```bash
   a的值为：8
   ```

3. 引用做形参

   引用相当于给一个变量起别名，引用形参相当于直接操作实参，没有拷贝过程

   ```cpp
   void fun(int &p){
       p=8;
   }
   int main(){
       int a=2;
       fun(a);
       printf("a的值为：%d",a);
       return 0;
   }
   ```

   ```
   a的值为：8
   ```

4. 指针引用做形参

   指针引用是指针的别名，在函数内部可以修改指针引用指向的地址，而传指针传入的是指针拷贝，更改拷贝指针指向的地址并不会修改原实参所指向地址。即指针引用在函数内部可以更改实参所指向的值（即在函数中传入指针引用的条件为需要作为左值来更改实参数值）

   ```cpp
   typedef struct {
       int a;
   }test;
   void init(test *&t){
       test c;
       c.a=6;
       t=&c;
   }
   int main(){
       test *t;
       t=(test*)malloc(sizeof(test));
       t->a=9;
       init(t);
       printf("a的值为：%d",t->a);
       return 0;
   }
   ```

   ```bash
   不用引用a的值为：9
   ```

5. 双指针做形参
   双指针在作为函数参数时，可以可以实现类似指针引用的效果，在另外一些地方，也可等价于指针数组

   ```c++
   #include<iostream>
   using namespace std;
   int main(int argc, char **argv){
       while(argc-- >0){
           printf("argv:%d,*argv++:%s\n", argc, *argv++);
       }
       return 0;
   }
   等价于
   #include<iostream>
   using namespace std;
   int main(int argc, char *argv[]){
       while(argc-- >0){
           printf("argv:%d,*argv++:%s\n", argc, *(argv++));
       }
       return 0;
   }
   ```

   

## 线性表

> 线性表就是可变数组，优点易于查找，且相较于数组更加灵活，存储密度大于链表，缺点是添加数据和删除数据的效率低于链表

- 线性表结构体定义

```cpp
typedef struct{
    Emltype Data[Maxsize]; //数据数组
    int length;            //动态数组长度
} Sqlist;
```

***

## 链表

### 单链表

> 单链表又称线性表的链式存储，链表的节点包含数据域和指针域，链表的头指针指向链表的头节点（若存在头节点）或者开始节点，头节点为一个不存储数据的节点，通常是为了操作防止出现链表为空而设置的。链表的优点是添加数据和删除数据的效率高于线性表，缺点是查找效率较低，且存储密度低于线性表。

```cpp
typedef struct LNode{
    Elemtype data;//数据域
    struct LNode *next;//指向下一节点的next指针
}LinkNode;
```

链表的插入方法有头插法和尾插法，头插法由于节点新建方法会导致输出链表时数据顺序与原输入数据顺序相反

### 双链表

> 双链表与单链表的区别为节点增加了节点的前驱指针，优点为可以快速访问到一个节点的前驱节点和后驱节点，且双链表可以使用二分查找使链表的查询效率提高一倍；缺点为在增删节点时比单链表复杂，内存利用低于单链表。

- 双链表节点定义

```cpp
typedef struct LinkNode{
    Elemtype data;          //双链表的数据域
    struct LinkNode *prior; //双链表的前驱指针
    struct LinkNode *next;  //双链表的后驱指针
} DLinkNode;
```

### 循环链表

> 作用是循环链表是无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活，循环链表的尾指针指向头节点。
> 
> 循环链表中没有NULL指针。涉及遍历操作时，其终止条件就不再是像非循环链表那样判别p或p-＞next是否为空，而是判别它们是否等于某一指定指针，如头指针或尾指针等。
> 
> 在单链表中，从一已知结点出发，只能访问到该结点及其后续结点，无法找到该结点之前的其它结点。而在单循环链表中，从任一结点出发都可访问到表中所有结点，这一优点使某些运算在单循环链表上易于实现。这样他就可以更高效的实现算法， 循环链表，其结构特点链表中最后一个结点的指针域不再是结束标记，而是指向整个链表的第一个结点，从而使链表形成一个环。和单链表相同，循环链表也有带头结点结构和不带头结点结构两种，带头结点的循环单链表实现插入和删除操作较为方便。这样就可以更有效率。

- 循环单链表结构体定义
  
  ```cpp
  typedef struct Node{
      Elemtype data;
      struct Node *next;
  } CLinkNode;
  ```
  
  循环单链表的插入和删除等与普通链表操作相比，为了操作简便通常将单独对首元节点和空表进行操作

------

## 栈

### 线性栈

> 线性栈是限定仅在表尾进行删除，增加操作的线性表。表尾端称为栈顶，表的头部称为栈底。当栈顶下标为-1时，栈为空，第一个元素的下标为0，以此类推。由于栈的特殊性质，每次退栈元素为栈顶元素，即遵循后进先出的规则，反序出栈

- 栈结构体定义

```cpp
typedef struct Stack{
    Elemtype data[Maxsize]; //数据域
    int top;//栈顶下标
}SqStack;
```

### 链栈

> 链栈是采用链式结构实现的栈，通常使用单链表实现，由于链表插入方法有头插法和尾插法，所以链栈的入栈也有两种实现方法，若使用头插法实现，则出栈从开始节点开始出栈，若使用尾插法则从尾部开始出栈。头插法的链栈最为方便，取出数据直接取得首元节点的值即可

- 链栈节点结构体定义

```cpp
typedef struct SNode{
    Elemtype data;//数据域
    struct SNode *next;//指向下一节点的next指针
}StackNode;
```

***

## 队列

### 顺序队列

> 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。为了队列判空的方便，会设置头尾两个指针，比如设置队头（尾）指针指向队头（尾）元素，队尾（头）指针指向尾（头）部后（前）一个位置，这样单队头尾指针相等时，即队列为空。普通顺序队列的缺点是会出现假溢出，存储空间利用不佳，通常采用循环队列解决这个问题。

- 普通顺序队列结构体定义

```cpp
typedef struct{
    Elemtype data[MaxSize];//数据域
    int front, rear;//定义队头指针和队尾指针
}SqQueue;
```

#### 队列的真假溢出

- 真溢出：给队列分配MaxSize为5，入队列达到6个元素，队列真溢出

- 假溢出：原先下标为0和1的元素出队，队头指针指向队头元素前一位，但此时虽然队列中还有两个空位，此时入队会造成假溢出。这是顺序队列的弊端，需要实现循环队列解决队列的真假溢出。
  
    ![image-20210803005815511](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210803005815511.png)

#### 顺序循环队列

> 循环队列就是将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用。在循环队列结构中，当存储空间的最后一个位置已被使用而再要进入队运算时，只需要存储空间的第一个位置空闲，便可将元素加入到第一个位置，即将存储空间的第一个位置作为队尾。 [1] 循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。
> 
> 在循环队列中，当队列为空时，有front=rear，而当所有队列空间全占满时，也有front=rear。为了区别这两种情况，规定循环队列最多只能有Max Size-1个队列元素，当循环队列中只剩下一个空存储单元时，队列就已经满了。因此，队列判空的条件是front=rear，而队列判满的条件是front=（rear+1)%Max Size。

- 循环队列的结构体定义
  
  ```cpp
  typedef struct{
      Elemtype data[Maxsize];//数据域
      int front,rear;//队头指针和队尾指针
  }Queue;
  ```

### 链式队列

> 链式队列就是使用链式存储结构存储的队列，与顺序队列相比，链式队列不会出现假溢出现象，因为每个节点的出队都会当场销毁该节点。链队结构包含两个节点类型的队列头尾指针

- 链式队列的结构体定义
  
  ```cpp
  typedef struct Node{
      Elemtype data;
      struct Node *next;
  } CLinNode; //节点类型
  typedef struct{
      CLinNode *front;
      CLinNode *rear;
  } CLinQue; //队列类型
  ```

## 串

> 串是由零个或多个字符组成的有限序列

### 1.顺序串

- 非紧缩格式顺序串结构体定义声明
  
  ```cpp
  typedef struct{
      char data[MaxSize];
      int length;
  }SqString
  ```

## 树

### 二叉树

> 二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树 的、互不相交的二叉树组成。由千这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空 树。

#### 性质

- 性质1 在二叉树的 第l层上至多有$2^{x-1}$个结点（$i\geq1$)。

- 性质2 深度为K的 二叉树至多有 $2^k-1$个结点 ($k\geq1$)。

- 性质3 对任何一棵二叉树T, 如果其终端结点数为$n_0$，度为2的结点数为$n_2$,则$n_0=n_2+1$

- 性质4 具有 n 个结点的完全二叉树的深度为llog心+ 1 

- 性质 5 如果对一棵有 n个结点的完全二叉树（其深度为llog2n」+ 1) 的结点按层序编号（从 第 1 层到第llog2n」+ 1 层， 每层从左到右）， 则对任一结点i(l�i�n), 有 119  120  1数据结构(C语言版）（第2版）I (1)如果i = 1, 则结点l是二叉树的根，无双亲；如果i> 1, 则其双亲PARENTi( )是结 点Lu2」。 ( 2 )如果2i>n, 则结点i无左孩子（结点i为叶子结点）；否则其左孩子LCHILD1)是结点 ( 2儿 (3)如果2门1>n, 则结缸无右孩子；否则其右孩子RCHILDi( )是结点2门l。

### 满二叉树

> 深度为 K且含有$2^k-1$个结点的二叉树。 图所示是一棵深度为3的满二叉树

![满二叉树](http://c.biancheng.net/uploads/allimg/190427/09452HG8-1.gif)

### 二叉树的存储结构

